package CDD.CollisionMap;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.HashMap;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.features2d.FastFeatureDetector;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;
import org.opencv.utils.Converters;

/**
* GripPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipeline {
	public static void main(String[] args) {
		GripPipeline pipeline = new GripPipeline();
        pipeline.process("CatNipGame\\app\\src\\main\\resources\\CDD\\textures\\map.png");
	}

	//Outputs
	private Mat rgbThreshold0Output = new Mat();
	private Mat rgbThreshold1Output = new Mat();
	private Mat rgbThreshold2Output = new Mat();
	public static ArrayList<MatOfPoint> findContours0Output = new ArrayList<MatOfPoint>();
	private ArrayList<MatOfPoint> findContours1Output = new ArrayList<MatOfPoint>();
	private ArrayList<MatOfPoint> findContours2Output = new ArrayList<MatOfPoint>();

	static {
		nu.pattern.OpenCV.loadLocally();
	}

  public Mat loadMap(String path) {
    Mat image = Imgcodecs.imread(path);

    // Check if the image was loaded successfully
    if (image.empty()) {
        System.out.println("Error: Could not load image!");
        return new Mat();
    } else {
        System.out.println("Image loaded successfully!");
    }
    return image;
  }

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public void process(String path) {
    Mat source0 = loadMap(path);

		// Step RGB_Threshold0:
		Mat rgbThreshold0Input = source0;
		double[] rgbThreshold0Red = {255.0, 255.0};
		double[] rgbThreshold0Green = {0.0, 0.0};
		double[] rgbThreshold0Blue = {0.0, 0.0};
		rgbThreshold(rgbThreshold0Input, rgbThreshold0Red, rgbThreshold0Green, rgbThreshold0Blue, rgbThreshold0Output);

		// Step RGB_Threshold1:
		Mat rgbThreshold1Input = source0;
		double[] rgbThreshold1Red = {0.0, 0.0};
		double[] rgbThreshold1Green = {119.24460431654676, 255.0};
		double[] rgbThreshold1Blue = {143.5521582733813, 255.0};
		rgbThreshold(rgbThreshold1Input, rgbThreshold1Red, rgbThreshold1Green, rgbThreshold1Blue, rgbThreshold1Output);

		// Step RGB_Threshold2:
		Mat rgbThreshold2Input = source0;
		double[] rgbThreshold2Red = {217.85071942446044, 255.0};
		double[] rgbThreshold2Green = {224.73021582733813, 255.0};
		double[] rgbThreshold2Blue = {0.0, 0.0};
		rgbThreshold(rgbThreshold2Input, rgbThreshold2Red, rgbThreshold2Green, rgbThreshold2Blue, rgbThreshold2Output);

		// Step Find_Contours0:
		Mat findContours0Input = rgbThreshold0Output;
		boolean findContours0ExternalOnly = false;
		findContours(findContours0Input, findContours0ExternalOnly, findContours0Output);

		// Step Find_Contours1:
		Mat findContours1Input = rgbThreshold1Output;
		boolean findContours1ExternalOnly = false;
		findContours(findContours1Input, findContours1ExternalOnly, findContours1Output);

		// Step Find_Contours2:
		Mat findContours2Input = rgbThreshold2Output;
		boolean findContours2ExternalOnly = false;
		findContours(findContours2Input, findContours2ExternalOnly, findContours2Output);


    System.out.println("==============================================\n Collision Map Contours\n==============================================");
    // Format contours
    for (int i = 0; i < findContours0Output.size(); i++) {
        Mat contour = findContours0Output.get(i);
        List<Point> points = new ArrayList<>();
        Converters.Mat_to_vector_Point(contour, points);

        System.out.println("Contour " + (i + 1) + ":");
        for (Point point : points) {
            System.out.println("  (" + point.x + ", " + point.y + ")");
        }
    }

    System.out.println("==============================================\n NPC AI Path Contours\n==============================================");
    // Format contours
    for (int i = 0; i < findContours2Output.size(); i++) {
        Mat contour = findContours2Output.get(i);
        List<Point> points = new ArrayList<>();
        Converters.Mat_to_vector_Point(contour, points);

        System.out.println("Contour " + (i + 1) + ":");
        for (Point point : points) {
            System.out.println("  (" + point.x + ", " + point.y + ")");
        }
    }

System.out.println("==============================================\n Game Triggers\n==============================================");
    // Format contours
    for (int i = 0; i < findContours1Output.size(); i++) {
        Mat contour = findContours1Output.get(i);
        List<Point> points = new ArrayList<>();
        Converters.Mat_to_vector_Point(contour, points);

        System.out.println("Contour " + (i + 1) + ":");
        for (Point point : points) {
            System.out.println("  (" + point.x + ", " + point.y + ")");
        }
    }

	}

	/**
	 * This method is a generated getter for the output of a RGB_Threshold.
	 * @return Mat output from RGB_Threshold.
	 */
	public Mat rgbThreshold0Output() {
		return rgbThreshold0Output;
	}

	/**
	 * This method is a generated getter for the output of a RGB_Threshold.
	 * @return Mat output from RGB_Threshold.
	 */
	public Mat rgbThreshold1Output() {
		return rgbThreshold1Output;
	}

	/**
	 * This method is a generated getter for the output of a RGB_Threshold.
	 * @return Mat output from RGB_Threshold.
	 */
	public Mat rgbThreshold2Output() {
		return rgbThreshold2Output;
	}

	/**
	 * This method is a generated getter for the output of a Find_Contours.
	 * @return ArrayList<MatOfPoint> output from Find_Contours.
	 */
	public ArrayList<MatOfPoint> findContours0Output() {
		return findContours0Output;
	}

	/**
	 * This method is a generated getter for the output of a Find_Contours.
	 * @return ArrayList<MatOfPoint> output from Find_Contours.
	 */
	public ArrayList<MatOfPoint> findContours1Output() {
		return findContours1Output;
	}

	/**
	 * This method is a generated getter for the output of a Find_Contours.
	 * @return ArrayList<MatOfPoint> output from Find_Contours.
	 */
	public ArrayList<MatOfPoint> findContours2Output() {
		return findContours2Output;
	}


	/**
	 * Segment an image based on color ranges.
	 * @param input The image on which to perform the RGB threshold.
	 * @param red The min and max red.
	 * @param green The min and max green.
	 * @param blue The min and max blue.
	 * @param output The image in which to store the output.
	 */
	private void rgbThreshold(Mat input, double[] red, double[] green, double[] blue,
		Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2RGB);
		Core.inRange(out, new Scalar(red[0], green[0], blue[0]),
			new Scalar(red[1], green[1], blue[1]), out);
	}

	/**
	 * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
	 * @param input The image on which to perform the Distance Transform.
	 * @param type The Transform.
	 * @param maskSize the size of the mask.
	 * @param output The image in which to store the output.
	 */
	private void findContours(Mat input, boolean externalOnly,
		List<MatOfPoint> contours) {
		Mat hierarchy = new Mat();
		contours.clear();
		int mode;
		if (externalOnly) {
			mode = Imgproc.RETR_EXTERNAL;
		}
		else {
			mode = Imgproc.RETR_LIST;
		}
		int method = Imgproc.CHAIN_APPROX_SIMPLE;
		Imgproc.findContours(input, contours, hierarchy, mode, method);
	}




}

